<template>
  <style>
    m-name, m-channels {
      display: block;
    }
    m-name {
      color: black;
      font-size: 200%;
    }
    m-channels {
      width: 100%;
      height: 100%;
      overflow-x: scroll;
      overflow-y: hidden;
    }
    m-channels x-channel {
      width: 300px;
      display: block;
      float: left;
    }
  </style>

  <button type="button" name="refresh">Refresh</button>
  <m-name></m-name>
  <m-channels></m-channels>
</template>

<script type="text/javascript">
  (function () {
    "use strict";

    var template = document.currentScript.ownerDocument.querySelector('template');

    class Board extends HTMLElement {
      createdCallback() {
        this.createShadowRoot().appendChild(document.importNode(template.content, true));
        this.config = null;
        this._data = null;

        this.$name = this.shadowRoot.querySelector('m-name');
        this.$channels = this.shadowRoot.querySelector('m-channels');
        this.$refresh = this.shadowRoot.querySelector('button[name=refresh]');

        this.$refresh.addEventListener('click', this.refresh.bind(this));
      }

      setName(name) {
        this.$name.textContent = name;
        return this;
      }

      setConfig(config) {
        console.log("board setConfig:", config);
        this.config = config;
        return this;
      }

      setData(data) {
        this._data = data;

        // set name
        this.setName(this.config.name);

        // Remove all children
        $.removeAllChild(this.$channels);

        // update new data
        this.config.channels.forEach(function (channelConfig, index) {
          this.$channels.appendChild(
            document.createElement('x-channel')
            .setData(channelConfig, this._data[index]));
        }, this);

        return this;
      }

      refresh() {
        var channels = this.config.channels;
        var allSources = new Set();
        channels.forEach(function (channel) {
          channel.sources.forEach(function (source) {
            allSources.add(source);
          });
        });
        console.log('allSources', allSources);

        // fetch all sources
        allSources.forEach(function (source) {
          document.services.twitter.fetch(source);
        });

        // get all data
        var allChannelsPromises = channels.reduce((all, channel) => {
          var allSourcesPromises = channel.sources.map((source) => document.services.twitter.get(source));
          all.push(Promise.all(allSourcesPromises));
          return all;
        }, []);
        console.log('all Promises', allChannelsPromises);

        var self = this;
        Promise.all(allChannelsPromises)
          .then(function (data) {
            console.log('allTweets:', data);
            localStorage.setItem('tweets', JSON.stringify(data));
            self.setData(data);
          });
      }
    }

    document.registerElement("x-board", Board);
  })();
</script>
