<template>
  <style>
    :host {
      display: block;
      height: 100%;
      width: 100%;
      overflow-x: scroll;
      overflow-y: hidden;
      white-space: nowrap; /* key to horizontal scrolling */
    }
    #m-channels {
      height: 100%;
    }
    .m-channel {
      display: inline-block; /* key to horizontal */
      height: 100%;
      width: 300px;
      white-space: normal; /* reset for children */
      border-left: 1px #eee solid;
    }
    .m-channel:last-child {
      border-right: 1px #eee solid;
    }
  </style>
  <div id="m-channels"></div>
</template>

<script type="text/javascript">
  (function () {
    "use strict";

    var template = document.currentScript.ownerDocument.querySelector('template');

    class Board extends HTMLElement {
      createdCallback() {
        this.createShadowRoot().appendChild(document.importNode(template.content, true));
        this.config = null;
        this._data = null;

        this.$channels = this.shadowRoot.querySelector('#m-channels');
      }

      setConfig(config) {
        console.log("board setConfig:", config);
        this.config = config;
        return this;
      }

      setData(data) {
        this._data = data;

        // Remove all children
        $.removeAllChild(this.$channels);

        if (!data) {
          return this;
        }

        // update new data
        this.config.channels.forEach(function (channel_config, index) {
          var $channel = document.createElement('x-channel').setData(channel_config, this._data[index]);
          var $channel_container = document.createElement('div');
          $channel_container.className = "m-channel";
          $channel_container.appendChild($channel);
          this.$channels.appendChild($channel_container);
          // this.$channels.appendChild($channel);
        }, this);

        return this;
      }

      refresh() {
        var channels = this.config.channels;
        var allSources = new Set();
        channels.forEach(function (channel) {
          channel.sources.forEach(function (source) {
            allSources.add(source);
          });
        });
        console.log('allSources', allSources);

        // fetch all sources
        allSources.forEach(function (source) {
          document.services.twitter.fetch(source);
        });

        // get all data
        var allChannelsPromises = channels.reduce((all, channel) => {
          var allSourcesPromises = channel.sources.map((source) => document.services.twitter.get(source));
          all.push(Promise.all(allSourcesPromises));
          return all;
        }, []);
        console.log('all Promises', allChannelsPromises);

        var self = this;
        Promise.all(allChannelsPromises)
          .then(function (data) {
            // cache up
            console.log('allTweets:', data);
            localStorage.setItem('tweets', JSON.stringify(data));
            self.setData(data);
          });
      }
    }

    document.registerElement("x-board", Board);
  })();
</script>
