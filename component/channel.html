<link rel="import" href="tweet.html">

<template>
  <style>
    :host {
      display: block;
      position: relative;
      height: 100%;
      width: 100%;
    }
    #header {
      color: orange;
      height: 24px;
      line-height: 24px;
      text-align: center;
      border-bottom: 1px #eee solid;
    }
    #tweets, #loading {
      position: absolute;
      width: 100%;
    }
    #tweets {
      top: 24px;
      bottom: 0;
      padding-bottom: 24px;
      overflow-x: hidden;
      overflow-y: auto;
    }
    #tweets x-tweet {
      border-bottom: 1px #eee solid;
    }

    #loading {
      bottom: 0;
      height: 24px;
      text-align: center;
    }
  </style>

  <div id="header"></div>
  <div id="tweets"></div>
  <div id="loading">Loading more...</div>
</template>

<script type="text/javascript">
  (function() {
    "use strict";

    var template = document.currentScript.ownerDocument.querySelector('template');

    class Channel extends XElement {
      createdCallback() {
        this.createShadowRoot().appendChild(document.importNode(template.content, true));
        this.config = null;
        this.data = [];
        this.fetching = false;
      }

      setConfig(config) {
        this.config = config;
        this.$('#header').textContent = config.name;
        return this;
      }

      refresh() {
        console.info('[channel] refresh', this.config.name);
        var client = document.cache.getTwitterClient(document.account);
        var source_promises = $.mapKeyValue(this.config.sources, (source, params) => {
          return client.fetch(source, params);
        });
        return Promise.all(source_promises)
          .then((data) => {
            this.setData(data);
            return data;
          });
      }

      fetchMore() {
        console.debug('scroll to bottom');
        if (this.fetching) {
          console.log('This channel is fetching, skip.');
          return;
        }
        try {
          this.fetching = true;
          this.$('#loading').show();

          // get the earlest tweet id in this channel
          var earlest_tweet_id;
          if (this.data) {
            earlest_tweet_id = this.data[this.data.length - 1].id_str;
            console.log('[channel] fetchMore: earlest_tweet_id', earlest_tweet_id);
            // Alternative: this.$('#tweets').lastChild.dataset.tweetId
          }

          // fetch more data
          var client = document.cache.getTwitterClient(document.account);
          var source_promises = $.mapKeyValue(this.config.sources, (source, params) => {
            params = Object.assign({}, params, {
              max_id: earlest_tweet_id,
            });
            return client.fetch(source, params);
          });
          return Promise.all(source_promises)
            .then((data) => {
              this.appendData(data);
              return data;
            });
        } finally {
          this.fetching = false;
          this.$('#loading').hide();
        }
      }

      transformData(data) {
        console.info('[channel] transformData', data);

        if (!$.isDefined(data)) {
          return [];
        }

        return data
          // flatten [[tweetsForSource1], [tweetsForSource2], ...]
          .reduce((all, current) => {
            return all.concat(current);
          }, [])
          // unify tweet into unique objects
          .map((tweet) => {
            return document.cache.getCurrentAccountTweet(tweet);
          })
          // Transform created_at field into Date object
          .map((tweet) => {
            tweet.created_at = new Date(tweet.created_at);
            return tweet;
          })
          // sort by created_at
          .sort((a, b) => {
            return b.created_at - a.created_at;
          });
      }

      clearData() {
        console.info('[channel] clearData');
        this.data = [];
        $.removeAllChildren(this.$('#tweets'));
      }

      setData(data) {
        console.info('[channel] setData', data);

        // Remove all children
        $.removeAllChildren(this.$('#tweets'));

        // transform data
        this.data = this.transformData(data);

        // create tweet elements
        this.data.forEach((tweet) => {
          this.$('#tweets').appendChild(document.createElement('x-tweet').setTweet(tweet));
        });

        // scroll event
        var $tweets = this.$('#tweets');
        $tweets.handle('scroll', () => {
          if ($tweets.scrollTop + $tweets.offsetHeight + 10 >= $tweets.scrollHeight) {
            this.fetchMore();
          }
        });

        // hide loading
        this.$('#loading').hide();

        return this;
      }

      appendData(data) {
        console.info('[channel] appendData', data);

        // append data
        var new_data = this.transformData(data)
          // remove duplicated tweet
          .filter((tweet) => {
            for (var i = this.data.length - 1; i >= 0; i--) {
              if (this.data[i].id_str === tweet.id_str) {
                return false; // don't keep this
              }
            }
            return true; // keep this
          });
        console.debug(new_data);
        this.data = [].concat(this.data, new_data);

        new_data.forEach((tweet) => {
          this.$('#tweets').appendChild(document.createElement('x-tweet').setTweet(tweet));
        });


        // hide loading
        this.$('#loading').hide();

        return this;
      }
    }

    document.registerElement("x-channel", Channel);
  })();
</script>
